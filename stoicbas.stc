

% ***************************************************************************
% ** COPYRIGHT (C) MASSACHUSETTS INSTITUTE OF TECHNOLOGY AND HARVARD       **
% ** UNIVERSITY, BIOMEDICAL ENGINEERING CENTER 1977.  ALL RIGHTS RESERVED. **
% ***************************************************************************

% BASIC DEFINITIONS
% J. SACHS 3/3/77

% 8080 ASSEMBLER
ASSEMBLER< DEFINITIONS

% REGISTER DEFINITIONS
0 'B CONSTANT   1 'C CONSTANT   2 'D CONSTANT
3 'E CONSTANT   4 'H CONSTANT   5 'L CONSTANT
6 'M CONSTANT   7 'A CONSTANT
6 'PSW CONSTANT 6 'SP CONSTANT

% INSTRUCTION DEFINITIONS
000 'NOP,  R0   001 'LXI,  R6   011 'DAD,  R1   013 'DCX,  R1
002 'STAX, R1   012 'LDAX, R1   004 'INR,  R1   005 'DCR,  R1
042 'SHLD, R7   052 'LHLD, R7   062 'STA,  R7   072 'LDA,  R7
007 'RLC,  R0   017 'RRC,  R0   027 'RAL,  R0   037 'RAR,  R0
047 'DAA,  R0   057 'CMA,  R0   067 'STC,  R0   077 'CMC,  R0
006 'MVI,  R5   100 'MOV,  R2   301 'POP,  R1   305 'PUSH, R1
200 'ADD,  R3   210 'ADC,  R3   220 'SUB,  R3   230 'SBB,  R3
240 'ANA,  R3   250 'XRA,  R3   260 'ORA,  R3   270 'CMP,  R3
306 'ADI,  R4   316 'ACI,  R4   326 'SUI,  R4   336 'SBI,  R4
346 'ANI,  R4   356 'XRI,  R4   366 'ORI,  R4   376 'CPI,  R4
300 'RNZ,  R0   310 'RZ,   R0   320 'RNC,  R0   330 'RC,   R0
340 'RPO,  R0   350 'RPE,  R0   360 'RP,   R0   370 'RM,   R0
303 'JMP,  R7   315 'CALL, R7   311 'RET,  R0   003 'INX,  R1
302 'JNZ,  R7   312 'JZ,   R7   322 'JNC,  R7   332 'JC,   R7
342 'JPO,  R7   352 'JPE,  R7   362 'JP,   R7   372 'JM,   R7
304 'CNZ,  R7   314 'CZ,   R7   324 'CNC,  R7   334 'CC,   R7
344 'CPO,  R7   354 'CPE,  R7   364 'CP,   R7   374 'CM,   R7
323 'OUT,  R4   333 'IN,   R4   343 'XTHL, R0   353 'XCHG, R0
363 'DI,   R0   373 'EI,   R0   351 'PCHL, R0   371 'SPHL, R0
166 'HLT,  R0   307 'RST,  R1   303 'IF,   R8   302 'IFNZ, R8
312 'IFZ,  R8   322 'IFNC, R8   332 'IFC,  R8   342 'IFPO, R8
352 'IFPE, R8   362 'IFP,  R8   372 'IFM,  R8

> DEFINITIONS

% DROP TOP 3 NUMBERS FROM STACK
'3DROP CODE<  H POP,  .  H POP,  .  H POP,  NEXT JMP,  >

% DROP TOP NUMBER FROM STACK
'DROP CODE<  JMP,  >

% DROP TOP 2 NUMBERS FROM STACK
'2DROP CODE<  JMP,  >

% DUPLOCATE TOP OF STACK
'DUP CODE<  H POP,  H PUSH,  PUSH JMP,  >

% DUPLICATE TOP - 1
'OVER CODE<  2 H LXI,  SP DAD,  @PUSH JMP,  >

% EXCHANGE TOP 2 NUMBERS ON STACK
'SWAP CODE<  H POP,  XTHL,  PUSH JMP,  >

% LOAD NUMBER ADDRESSED BY TOP OF STACK
'@ CODE<  H POP,  @PUSH JMP,  >

% STORE NUMBER AT TOP - 1 AT ADDRESS AT TOP
'! CODE<  H POP,  D POP,  E M MOV,  H INX,  D M MOV,  NEXT JMP,  >

% INCREMENT TOP OF STACK
'1+ CODE<  H POP,  H INX,  PUSH JMP,  >

% DECREMENT TOP OF STACK
'1- CODE<  H POP,  H DCX,  PUSH JMP,  >

% INCREMENT TOP OF STACK BY 2
'2+ CODE<  H POP,  H INX,  H INX,  PUSH JMP,  >

% DECREMENT TOP OF STACK BY 2
'2- CODE<  H POP,  H DCX,  H DCX,  PUSH JMP,  >

% NEGATE TOP OF STACK
'MINUS CODE<  H POP,  -HL CALL,  PUSH JMP,  >

% COMPLEMENT TOP OF STACK
'NOT CODE<  H POP,  -HL 1+ CALL,  PUSH JMP,  >

% ADD TOP 2 NUMBERS ON STACK
'+ CODE<  H POP,  D POP,  D DAD,  PUSH JMP,  >

% SUBTRACT TOP 2 NUMBERS ON  STACK
'- CODE<  H POP,  -HL CALL,  D POP,  D DAD,  PUSH JMP,  >

% LOGICAL AND TOP 2 NUMBERS ON STACK
'AND CODE<  B POP,  H POP,  B A MOV,  H ANA,  A H MOV,
  C A MOV,  L ANA,  A L MOV,  PUSH JMP,  >

% LOGICAL OR TOP 2 NUMBERS ON STACK
'OR CODE<  B POP,  H POP,  B A MOV,  H ORA,  A H MOV,
  C A MOV,  L ORA,  A L MOV,  PUSH JMP,  >

% LOGICAL XOR TOP 2 NUMBERS ON STACK
'XOR CODE<  B POP,  H POP,  B A MOV,  H XRA,  A H MOV,
  C A MOV,  L XRA,  A L MOV,  PUSH JMP,  >

% LOAD BYTE ADDRESSED BY TOP OF STACK
'B@ CODE<  H POP,  M L MOV,  0 H MVI,  PUSH JMP,  >

% STORE BYTE AT TOP - 1 AT ADDRESS AT TOP
'B! CODE<  H POP,  D POP,  E M MOV,  NEXT JMP,  >

% EXECUTE WORD WHOSE ADDRESS IS AT TOP OF STACK
'EXEC CODE<  D POP,  D H MOV,  E L MOV,  H DCX,  M A MOV,  H DCX,
  M L MOV,  A H MOV,  PCHL,  >

% DEFINE COMMONLY USED CONSTANTS
-1 '-1 CONSTANT
0 '0 CONSTANT
1 '1 CONSTANT
2 '2 CONSTANT

% DEFINE THE ADDRESSES OF VARIABLES INSIDE THE KERNEL
%
% NOTE THAT THESE OFFSETS MUST BE MODIFIED IF ANY VARIABLES
% ARE ADDED, REMOVED, OR REARRANGED.
%
% IF "STATE" IS NOT THE 1ST STOIC VARIABLE, "RDCI" AND "WRCI"
% MUST ALSO BE MODIFIED.

STATE 1 + 'CHECK CONSTANT
STATE 2 + 'COLUMN CONSTANT
STATE 5 + '.R CONSTANT
STATE 7 + '.L CONSTANT
STATE 11 + '.V CONSTANT
STATE 13 + '.D CONSTANT
STATE 15 + '.C CONSTANT
STATE 17 + 'CURRENT CONSTANT
STATE 21 + 'RADIX CONSTANT
STATE 23 + 'PROMPT CONSTANT
STATE 25 + 'ERRMSG CONSTANT
STATE 27 + 'ENT CONSTANT
STATE 31 + 'MEMORY CONSTANT
STATE 33 + 'LIT CONSTANT
STATE 35 + '(TTYIN) CONSTANT
STATE 37 + '(TTYOU) CONSTANT
STATE 41 + '(ABORT) CONSTANT

% FINISH UP ASSEMBLER
ASSEMBLER< DEFINITIONS

STATE 3 + '.I CONSTANT
STATE 57 + 'T1 CONSTANT

'THEN, : . SWAP ! ;
'ELSE, : IF, SWAP THEN, ;

> DEFINITIONS

% COMPARISONS WITH ZERO
'EQZ CODE<  D POP,  D A MOV,  E ORA,  0PUSH JNZ,  -1PUSH JMP,  >
'NEZ CODE<  D POP,  D A MOV,  E ORA,  0PUSH JZ,  -1PUSH JMP,  >
'LTZ CODE<  D POP,  D A MOV,  A ORA,  0PUSH JP,  -1PUSH JMP,  >
'GEZ CODE<  D POP,  D A MOV,  A ORA,  0PUSH JM,  -1PUSH JMP,  >
'LEZ CODE<  D POP,  D DCX,  D A MOV,  A ORA,  0PUSH JP,  -1PUSH JMP,  >
'GTZ CODE<  D POP,  D DCX,  D A MOV,  A ORA,  0PUSH JM,  -1PUSH JMP,  >

% EQUALITY COMPARISONS
'EQ CODE<  H POP,  D POP,  H A MOV,  D CMP,  0PUSH JNZ,
  L A MOV,  E CMP,  0PUSH JNZ,  -1PUSH JMP,  >
'NE CODE<  H POP,  D POP,  H A MOV,  D CMP,  -1PUSH JNZ,
  L A MOV,  E CMP,  -1PUSH JNZ,  0PUSH JMP,  >

% SIGNED COMPARISONS
'LT CODE<  H POP,  D POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  -1PUSH JM,  0PUSH JMP,  >
'GE CODE<  H POP,  D POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  0PUSH JM,  -1PUSH JMP,  >
'LE CODE<  D POP,  H POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  0PUSH JM,  -1PUSH JMP,  >
'GT CODE<  D POP,  H POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  -1PUSH JM,  0PUSH JMP,  >

% UNSIGNED COMPARISONS
'ULT CODE<  H POP,  D POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  -1PUSH JC,  0PUSH JMP,  >
'UGE CODE<  H POP,  D POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  0PUSH JC,  -1PUSH JMP,  >
'ULE CODE<  D POP,  H POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  0PUSH JC,  -1PUSH JMP,  >
'UGT CODE<  D POP,  H POP,  E A MOV,  L SUB,  D A MOV,  H SBB,
  -1PUSH JC,  0PUSH JMP,  >

% LOAD INDIRECT TOP OF STACK
'@@ CODE<  H POP,  M E MOV,  H INX,  M D MOV,  XCHG,  @PUSH JMP,  >

% STORE TOP - 1 INDIRECT TOP OF STACK
'@! CODE<  H POP,  M E MOV,  H INX,  M D MOV,  XCHG,  D POP,  E M MOV,
  H INX,  D M MOV,  NEXT JMP,  >

% INCREMENT WORD ADDRESSED BY TOP OF STACK
'1+! CODE<  H POP,  M INR,  NEXT JNZ,  H INX,  M INR,  NEXT JMP,  >

% DECREMENT WORD ADDRESSED BY TOP OF STACK
'1-! CODE<  H POP,  M E MOV,  H INX,  M D MOV,  D DCX,  D M MOV,
  H DCX,  E M MOV,  NEXT JMP,  >

% MOVE BYTES FORWARD FROM ADDRESS AT TOP - 2 TO ADDRESS AT TOP - 1
% BYTE COUNT AT TOP
'MVBYTES CODE<  H POP,  D POP,  B POP,  H A MOV,  A ORA,  NEXT JM,
  L ORA,  NEXT JZ,  .  B LDAX,  D STAX,  B INX,  D INX,  H DCX,  H A MOV,
  L ORA,  JNZ,  NEXT JMP,  >

% MOVE BYTES BACKWARD FROM ADDRESS AT TOP - 2 TO ADDRESS AT TOP - 1
% BYTE COUNT AT TOP
'RMVBYTES CODE<  H POP,  D POP,  B POP,  H A MOV,  A ORA,  NEXT JM,
  L ORA,  NEXT JZ,  .  B LDAX,  D STAX,  B DCX,  D DCX,  H DCX,  H A MOV,
  L ORA,  JNZ,  NEXT JMP,  >

% FILL ARRAY WHOSE ADDRESS IS AT TOP - 2 WITH DATA AT TOP
% WORD COUNT AT TOP - 1
'FILL CODE<  D POP,  .  B POP,  H POP,  B A MOV,  A ORA,  NEXT JM,
  C ORA,  NEXT JZ,  .  E M MOV,  H INX,  D M MOV,  H INX,  B DCX,
  B A MOV,  C ORA,  JNZ,  NEXT JMP,  >

% ZERO FILL ARRAY WHOSE ADDRESS IS AT TOP - 1
% WORD COUNT AT TOP
'0FILL CODE<  0 D LXI,  JMP,  >

% ADD NUMBER AT TOP - 1 TO LOCATION ADDRESSED BY TOP
'+! CODE<  H POP,  M E MOV,  H INX,  M D MOV,  XCHG,  B POP,  B DAD,
  XCHG,  D M MOV,  H DCX,  E M MOV,  NEXT JMP,  >

% SET PRECEDENCE BIT OF MOST RECENTLY DEFINED WORD
'IMMEDIATE CODE<  CURRENT LHLD,  M E MOV,  H INX,  M D MOV,  -12 H LXI,
  D DAD,  M A MOV,  200 XRI,  A M MOV,  NEXT JMP,  >

% STORE TOP AT LOCATION ADDRESSED BY TOP - 1
'<- CODE<  D POP,  H POP,  E M MOV,  H INX,  D M MOV,  NEXT JMP,  >

% STORE ZERO AT LOCATION ADDRESSED BY TOP
'0<- CODE<  H POP,  0 M MVI,  H INX,  0 M MVI,  NEXT JMP,  >

% STORE ONES AT LOCATION ADDRESSED BY TOP
'-1<- CODE<  H POP,  -1 M MVI,  H INX,  -1 M MVI,  NEXT JMP,  >

% APPEND STRING WHOSE ADDRESS IS AT TOP TO END OF DICTIONARY
'S, CODE<  H POP,  M A MOV,  A INR,  .  H PUSH,  PSW PUSH,  M A MOV,
  (B,) CALL,  PSW POP,  H POP,  H INX,  A DCR,  NEXT JZ,  JMP,  >

ASSEMBLER< DEFINITIONS

% NEGATE (BC)
.
  B DCX,  B A MOV,  CMA,  A B MOV,  C A MOV,  CMA,  A C MOV,  RET,
'-BC CONSTANT

% NEGATE (DE)
.
  D DCX,  D A MOV,  CMA,  A D MOV,  E A MOV,  CMA,  A E MOV,  RET,
'-DE CONSTANT

% NEGATE (HL,DE)
.
  -HL 1+ CALL,  -DE CALL,  D A MOV,  E ORA,  RNZ,  H INX,  RET,
'-HLDE CONSTANT

% SIGNED MULTIPLY (HL)*(DE)->(HLDE)
.
  D A MOV,  H XRA,  PSW PUSH,  D A MOV,
  A ORA,  -DE CM,  H A MOV,  A ORA,  -HL CM,
  MUL CALL,  PSW POP,  -HLDE CM,  RET,
'SMUL CONSTANT

% UNSIGNED DIVIDE (HLDE)/(BC)->(DE),(HL) (QUOTIENT,REMAINDER)
.
  -BC CALL,  20 A MVI,  . <L  . <L  . <L  H DAD,  IFC,  XCHG,  H DAD,
  XCHG,  IFNC,  L INR,  THEN,  H PUSH,  B DAD,  IFC,  H POP,  A DCR,
  L> JNZ,  RET,  THEN,  E INR,  SP INX,  SP INX,  A DCR,  L> JNZ,  RET,
  THEN,  XCHG,  H DAD,  XCHG,  IFNC,  L INR,  THEN,  B DAD,  E INR,
  A DCR,  L> JNZ,  RET,
'DIV CONSTANT

% SIGNED DIVIDE SUBROUTINE
.
  H A MOV,  A ORA,  PSW PUSH,  B XRA,
  PSW PUSH,  H A MOV,  A ORA,  -HLDE CM,  B A MOV,
  A ORA,  -BC CM,  DIV CALL,  PSW POP,  -DE CM,
  PSW POP,  -HL CM,  RET,
'SDIV CONSTANT
> DEFINITIONS

% PUSH CURRENT VALUE OF COMPILE BUFFER OUTPUT PTR
'C. CODE<  .C LHLD,  PUSH JMP,  >

% INCREMENT CHECK
'+CHECK CODE<  CHECK H LXI,  M INR,  NEXT JMP,  >

% DECREMENT CHECK, ERROR IF MINUS
. "SYNTAX ERROR" S,
'-CHECK CODE<  CHECK H LXI,  M DCR,  M A MOV,  60 CPI,  NEXT JP,
  H LXI,  ERROR JMP,  >

% DEFINE BEGIN, END, REPEAT, IF, THEN, ELSE
'BEGIN : +CHECK C. 2- ;  IMMEDIATE
'END : -CHECK () (IF) C, C. - C, ;  IMMEDIATE
'REPEAT : -CHECK -CHECK SWAP () (ELSE) C, C. - C, C. 2- OVER - <- ;  IMMEDIATE
'IF : +CHECK () (IF) C, C. 0 C, ;  IMMEDIATE
'THEN : -CHECK C. 2- OVER - <- ;  IMMEDIATE
'ELSE : -CHECK +CHECK () (ELSE) C, C. OVER - <- C. 0 C, ;  IMMEDIATE

% DEFINE (, U(, )
'(() CODE<  D POP,  D A MOV,  A ORA,  () (ELSE) JM,  .  E ORA,  () (ELSE) JZ,
  .L LHLD,  6 B LXI,  B DAD,  .L SHLD,  E M MOV,  H INX,  D M MOV,  .I LHLD,
  H INX,  H INX,  .I SHLD,  NEXT JMP,  >
'(U() CODE<  D POP,  D A MOV,  JMP,  >
'()) CODE<  .L LHLD,  M E MOV,  H INX,  M D MOV,  D DCX,  D M MOV,  H DCX,
  E M MOV,  D A MOV,  E ORA,  () (ELSE) JNZ,  .L LHLD,  -6 D LXI,  D DAD,
  .L SHLD,  .I LHLD,  H INX,  H INX,  .I SHLD,  NEXT JMP,  >

'( : +CHECK () (() C, C. 0 C, ;  IMMEDIATE
'U( : +CHECK () (U() C, C. 0 C, ;  IMMEDIATE
') : -CHECK () ()) C, DUP C. OVER - <- C. - C, ;  IMMEDIATE

% DEFINE DO, LOOP, AND +LOOP
'(DO) CODE<  D POP,  B POP,  E A MOV,  C SUB,  D A MOV,  B SBB,
  () (ELSE) JP,  .L LHLD,  H INX,  H INX,  E M MOV,  H INX,  D M MOV,
  H INX,  C M MOV,  H INX,  B M MOV,  H INX,  .L SHLD,  E M MOV,  H INX,
  D M MOV,  .I LHLD,  H INX,  H INX,  .I SHLD,  NEXT JMP,  >
'(LOOP) CODE<  .L LHLD,  M E MOV,  H INX,  M D MOV,  D INX,  .  D M MOV,
  H DCX,  E M MOV,  H DCX,  M B MOV,  H DCX,  M C MOV,  E A MOV,  C SUB,
  D A MOV,  B SBB,  () (ELSE) JM,  .L LHLD,  -6 D LXI,  D DAD,  .L SHLD,
  .I LHLD,  H INX,  H INX,  .I SHLD,  NEXT JMP,  >
'(+LOOP) CODE<  .L LHLD,  M E MOV,  H INX,  M D MOV,  XCHG,  B POP,
  B DAD,  XCHG,  JMP,  >

'DO : +CHECK () (DO) C, C. 0 C, ;  IMMEDIATE
'LOOP : -CHECK () (LOOP) C, DUP C. OVER - <- C. - C, ;  IMMEDIATE
'+LOOP : -CHECK () (+LOOP) C, DUP C. OVER - <- C. - C, ;  IMMEDIATE

% DEFINE UDO, ULOOP, AND U+LOOP
'(UDO) CODE<  D POP,  B POP,  E A MOV,  C SUB,  D A MOV,  B SBB,
  () (ELSE) JNC,  .L LHLD,  H INX,  H INX,  E M MOV,  H INX,  D M MOV,
  H INX,  C M MOV,  H INX,  B M MOV,  H INX,  .L SHLD,  E M MOV,  H INX,
  D M MOV,  .I LHLD,  H INX,  H INX,  .I SHLD,  NEXT JMP,  >
'(ULOOP) CODE<  .L LHLD,  M E MOV,  H INX,  M D MOV,  D INX,  .  D M MOV,
  H DCX,  E M MOV,  H DCX,  M B MOV,  H DCX,  M C MOV,  E A MOV,  C SUB,
  D A MOV,  B SBB,  () (ELSE) JC,  .L LHLD,  -6 D LXI,  D DAD,  .L SHLD,
  .I LHLD,  H INX,  H INX,  .I SHLD,  NEXT JMP,  >
'(U+LOOP) CODE<  .L LHLD,  M E MOV,  H INX,  M D MOV,  XCHG,  B POP,
  B DAD,  XCHG,  JMP,  >

'UDO : +CHECK () (UDO) C, C. 0 C, ;  IMMEDIATE
'ULOOP : -CHECK () (ULOOP) C, DUP C. OVER - <- C. - C, ;  IMMEDIATE
'U+LOOP : -CHECK () (U+LOOP) C, DUP C. OVER - <- C. - C, ;  IMMEDIATE

% DO LOOP INDICES
'I CODE<  .L LHLD,  @PUSH JMP,  >
'J CODE<  .L LHLD,  -6 D LXI,  D DAD,  @PUSH JMP,  >
'K CODE<  .L LHLD,  -14 D LXI,  D DAD,  @PUSH JMP,  >

% REVERSE DO LOOP INDICES
'I' CODE<  .L LHLD,  . .  H INX,  M D MOV,  H DCX,  M E MOV,  H DCX,
  -DE 1+ CALL,  M B MOV,  H DCX,  M C MOV,  H DCX,  XCHG,  B DAD,
  XCHG,  M B MOV,  H DCX,  M C MOV,  XCHG,  B DAD,  PUSH JMP,  >
'J' CODE<  -6 D LXI,  .L LHLD,  D DAD,  JMP,  >
'K' CODE<  -14 D LXI,  .L LHLD,  D DAD,  JMP,  >

% EXIT FROM DO LOOP OR ITERATION BRACKETS
'EXIT CODE<  .L LHLD,  H INX,  0 M MVI,  H DCX,  1 M MVI,  H DCX,  0 M MVI,
  H DCX,  1 M MVI,  NEXT JMP,  >

% PUSH NUMBER ON RETURN STACK
'<R CODE<  .R LHLD,  H INX,  H INX,  .R SHLD,  D POP,  E M MOV,  H INX,
  D M MOV,  NEXT JMP,  >

% POP NUMBER FROM RETURN STACK
'R> CODE<  .R LHLD,  M E MOV,  H INX,  M D MOV,  H DCX,  H DCX,  H DCX,
  .R SHLD,  PUSHD JMP,  >

% ABSOLUTE VALUE OF TOP OF STACK
'ABS CODE<  H POP,  H A MOV,  A ORA,  -HL CM,  PUSH JMP,  >

% ADD NUMBER AT TOP TO DOUBLE PRECISION INTEGER AT TOP-2,TOP-1
'M+ CODE<  B POP,  .  D POP,  H POP,  B DAD,  XCHG,  DPUSH JNC,  H INX,
  DPUSH JMP,  >

% SUBTRACT NUMBER AT TOP FROM DOUBLE PRECISION INTEGER AT TOP-2,TOP-1
'M- CODE<  B POP,  -BC CALL,  JMP,  >

% DIVIDE TOP OF STACK BY 2 (SIGNED)
'2/ CODE<  H POP,  H A MOV,  A ORA,  IFP,  STC,  THEN,  .  RAR,
  A H MOV,  L A MOV,  RAR,  A L MOV,  PUSH JMP,  >

% DIVIDE TOP OF STACK BY 2 (UNSIGNED)
'U2/ CODE<  H POP,  H A MOV,  A ORA,  JMP,  >

% MULTIPLY TOP OF STACK BY 2
'2* CODE<  H POP,  H DAD,  PUSH JMP,  >

% LEFT SHIFT TOP - 1 N PLACES; N AT TOP
'LSHIFT CODE<  D POP,  H POP,  D A MOV,  A ORA,  PUSH JM,  E ORA,
  .  PUSH JZ,  H DAD,  E DCR,  JMP,  >

% RIGHT SHIFT TOP - 1 N PLACES; N AT TOP
'RSHIFT CODE<  D POP,  H POP,  D A MOV,  A ORA,  PUSH JM,  E ORA,
  .  PUSH JZ,  H A MOV,  RAL,  H A MOV,  RAR,  A H MOV,  L A MOV,  RAR,
  A L MOV,  E DCR,  JMP,  >

% UNSIGNED RIGHT SHIFT TOP - 1 N PLACES; N AT TOP
'URSHIFT CODE<  D POP,  H POP,  D A MOV,  A ORA,  PUSH JM,  E ORA,
  .  PUSH JZ,  A ORA,  H A MOV,  RAR,  A H MOV,  L A MOV,  RAR,  A L MOV,
  E DCR,  JMP,  >

% LEFT SHIFT TOP-2,TOP-1 N PLACES; N AT TOP
'DLSHIFT CODE<  B POP,  H POP,  D POP,  B A MOV,  A ORA,  DPUSH JM,
  C ORA,  .  DPUSH JZ,  XCHG,  H DAD,  PSW PUSH,  XCHG,  H DAD,  PSW POP,
  IFNC,  H INX,  THEN,  C DCR,  JMP,  >

% RIGHT SHIFT TOP-2,TOP-1 N PLACES; N AT TOP
'DRSHIFT CODE<  B POP,  H POP,  D POP,  B A MOV,  A ORA,  DPUSH JM,  C ORA,
  .  DPUSH JZ,  H A MOV,  RAL,  H A MOV,  RAR,  A H MOV,  L A MOV,  RAR,
  A L MOV,  D A MOV,  RAR,  A D MOV,  E A MOV,  RAR,  A E MOV,  C DCR,  JMP,  >

% UNSIGNED RIGHT SHIFT TOP-2,TOP-1 N PLACES; N AT TOP
'DURSHIFT CODE<  B POP,  H POP,  D POP,  B A MOV,  A ORA,  DPUSH JM,  C ORA,
  .  DPUSH JZ,  A ORA,  H A MOV,  RAR,  A H MOV,  L A MOV,  RAR,  A L MOV,
  D A MOV,  RAR,  A D MOV,  E A MOV,  RAR,  A E MOV,  C DCR,  JMP,  >

% MISCELLANEOUS FIXED POINT MULTIPLY AND DIVIDE OPERATORS
'UM* CODE<  D POP,  H POP,  MUL CALL,  DPUSH JMP,  >
'U* CODE<  D POP,  H POP,  MUL CALL,  PUSHD JMP,  >
'U/ CODE<  B POP,  0 H LXI,  D POP,  DIV CALL,  PUSHD JMP,  >
'U/MOD CODE<  B POP,  0 H LXI,  D POP,  DIV CALL,  DPUSH JMP,  >
'UM/MOD CODE<  B POP,  H POP,  D POP,  DIV CALL,  DPUSH JMP,  >
'UMOD CODE<  B POP,  0 H LXI,  D POP,  DIV CALL,  PUSH JMP,  >
'UM/ CODE<  B POP,  H POP,  D POP,  DIV CALL,  PUSHD JMP,  >
'U*/ CODE<  B POP,  D POP,  H POP,  B PUSH,  MUL CALL,  B POP,
  DIV CALL,  PUSHD JMP,  >

'* CODE<  D POP,  H POP,  SMUL CALL,  PUSHD JMP,  >
'/ CODE<  B POP,  D POP,  D A MOV,  A ORA,  0 H LXI,  IFP,  H DCX,  THEN,
  SDIV CALL,  PUSHD JMP,  >
'MOD CODE<  B POP,  D POP,  D A MOV,  A ORA,  0 H LXI,  IFP,  H DCX,  THEN,
  SDIV CALL,  PUSH JMP,  >
'M* CODE<  D POP,  H POP,  SMUL CALL,  DPUSH JMP,  >
'M/ CODE<  B POP,  H POP,  D POP,  SDIV CALL,  PUSHD JMP,  >
'/MOD CODE<  B POP,  D POP,  D A MOV,  A ORA,  0 H LXI,  IFP,  H DCX,  THEN,
  SDIV CALL,  DPUSH JMP,  >
'M/MOD CODE<  B POP,  H POP,  D POP,  SDIV CALL,  DPUSH JMP,  >
'*/ CODE<  B POP,  D POP,  H POP,  B PUSH,  SMUL CALL,  B POP,
  SDIV CALL,  PUSHD JMP,  >

% MOVE NUMBER ADDRESSED BY TOP - 1 TO LOCATION ADDRESSED BY TOP
'MOVE CODE<  B POP,  D POP,  D LDAX,  B STAX,  D INX,  B INX,  D LDAX,
  B STAX,  NEXT JMP,  >

% EXCHANGE NUMBER ADDRESSED BY TOP - 1 WITH NUMBER ADDRESSED BY TOP
'XCHG CODE<  D POP,  H POP,  M C MOV,  D LDAX,  A M MOV,  C A MOV,  D STAX,
  H INX,  D INX,  M C MOV,  D LDAX,  A M MOV,  C A MOV,  D STAX,  NEXT JMP,  >

% GET CURRENT VALUE OF STACK PTR
'S@ CODE<  0 H LXI,  SP DAD,  PUSH JMP,  >

% COPY TOP - 2
'2OVER CODE<  4 H LXI,  SP DAD,  @PUSH JMP,  >

% COPY TOP - 3
'3OVER CODE<  6 H LXI,  SP DAD,  @PUSH JMP,  >

% STORE TOP AT TOP - 1
'UNDER CODE<  H POP,  D POP,  PUSH JMP,  >

% STORE TOP AT TOP - 2
'2UNDER CODE<  4 H LXI,  .  SP DAD,  D POP,  E M MOV,  H INX,  D M MOV,
  NEXT JMP,  >

% STORE TOP AT TOP - 3
'3UNDER CODE<  6 H LXI,  JMP,  >

% DUPLICATE TOP-1,TOP
'DDUP CODE<  H POP,  D POP,  D PUSH,  H PUSH,  DPUSH JMP,  >

% DUPLICATE TOP-3,TOP-2
'DOVER CODE<  6 H LXI,  SP DAD,  M E MOV,  H INX,  M D MOV,  D PUSH,
  H DCX,  H DCX,  H DCX,  @PUSH JMP,  >

% STORE TOP-1,TOP AT TOP-3,TOP-2
'DUNDER CODE<  H POP,  D POP,  B POP,  B POP,  DPUSH JMP,  >

% EXCHANGE TOP-1,TOP WITH TOP-3,TOP-2
'DSWAP CODE<  B POP,  H POP,  T1 SHLD,  H POP,  T1 2+ SHLD,  D POP,
  T1 LHLD,  H PUSH,  B PUSH,  T1 2+ LHLD,  DPUSH JMP,  >

% EXCHANGE TOP-2 WITH TOP-1
'2SWAP CODE<  H POP,  B POP,  D POP,  B PUSH,  DPUSH JMP,  >

% TOP -> TOP-2 -> TOP-1 -> TOP
'+ROT CODE<  B POP,  H POP,  D POP,  B PUSH,  DPUSH JMP,  >

% TOP -> TOP-1 -> TOP-2 -> TOP
'-ROT CODE<  D POP,  B POP,  H POP,  B PUSH,  DPUSH JMP,  >

% EXCHANGE TOP WITH TOP-2
'FLIP CODE<  B POP,  D POP,  H POP,  B PUSH,  DPUSH JMP,  >

% SET RADIX TO OCTAL
'OCTAL : 10 RADIX ! ;

% SET RADIX TO DECIMAL
'DECIMAL : 12 RADIX ! ;

% SET RADIX TO HEXADECIMAL
'HEX : 20 RADIX ! ;

% DEFINE VARIABLE, ARRAY
'VARIABLE : CONSTANT ;CODE< PUSHD JMP, >
'ARRAY : 0 SWAP VARIABLE 1- ( 0 , ) ;

% DEFINE BRANCH
'BRANCH : . 14 + SWAP CONSTANT 0 , ;CODE<  (BRANCH) JMP,  >

% LOOK UP STRING WHOSE ADDRESS IS AT TOP, RETURN ADDR OF WORD IF FOUND
'ADDRESS : LOOKUP NOT IF "UNDEFINED" ERR THEN ;

% DELETE DICTIONARY ENTRIES BACK TO WORD WHOSE NAME IS AT TOP
'FORGET : ADDRESS DUP 12 - .D ! 4 - @ CURRENT @! ;

% SIGNED MAXIMUM OF TOP, TOP-1
'MAX : DDUP GT IF DROP ELSE UNDER THEN ;

% SIGNED MINIMUM OF TOP, TOP-1
'MIN : DDUP LT IF DROP ELSE UNDER THEN ;

% UNSIGNED MAXIMUM OF TOP, TOP-1
'UMAX : DDUP UGT IF DROP ELSE UNDER THEN ;

% UNSIGNED MINIMUM OF TOP, TOP-1
'UMIN : DDUP ULT IF DROP ELSE UNDER THEN ;

% GET BYTE COUNT, BYTE POINTER TO STRING WHOSE ADDRESS IS AT TOP
'COUNT CODE<  H POP,  M A MOV,  H INX,  H PUSH,  0 H MVI,  A L MOV,
  PUSH JMP,  >

% OUTPUT A BYTE TO TTY
'<TTO> CODE<  H POP,  L A MOV,  (TTO) CALL,  NEXT JMP,  >

% INPUT A BYTE FROM TTY
'<TTI> CODE<  (TTI) CALL,  A L MOV,  0 H MVI,  PUSH JMP,  >

% SET UP CHARACTER INPUT, OUTPUT VARIABLES
() <TTO> 'OUT VARIABLE
() <TTI> 'IN VARIABLE

% DEFINE CHARACTER INPUT, OUTPUT WORDS
'TYO : OUT @ EXEC ;
'TYI : IN @ EXEC ;

% OUTPUT N BYTES STARTING AT ADDRESS AT TOP - 1; N AT TOP
'TYPE : OVER + SWAP UDO I B@ TYO ULOOP ;

% OUTPUT STRING WHOSE ADDRESS IS AT TOP
'MSG : COUNT TYPE ;

% OUTPUT AT CARRIAGE RETURN
'CR : 15 TYO ;

% OUTPUT A CARRAIGE RETURN IS COLUMN IS NON-ZERO
'IFCR : COLUMN B@ IF CR THEN ;

% OUTPUT A SPACE
'SPACE : 40 TYO ;

% OUTPUT N SPACES; N AT TOP
'SPACES : ( SPACE ) ;

% TAB TO COLUMN N; N AT TOP
'TAB : COLUMN B@ - SPACES ;

% COMPLEMENT STATE
'// CODE<  STATE LDA,  CMA,  STATE STA,  NEXT JMP,  >  IMMEDIATE

% GIVE "REDEFINING" ERROR ON ENTER
'ENT0 : DUP LOOKUP IF DROP IFCR "REDEFINING " MSG DUP MSG CR THEN ENT0 ;
() ENT0 ENT !

% NUMBER CONVERSION PACKAGE

0 '#CNT VARIABLE	% STRING LENGTH
0 '#PTR VARIABLE	% POINTER TO STRING

% OUTPUT A BYTE TO NUMBER STRING
'#PUT CODE<  #CNT LHLD,  H INX,  #CNT SHLD,  #PTR LHLD,  H DCX,  #PTR SHLD,
  D POP,  E M MOV,  NEXT JMP,  >

% INITIATE NUMBER CONVERSION
'<# CODE<  .D LHLD,  40 D LXI,  D DAD,  #PTR SHLD,  0 H LXI,  #CNT SHLD,
  NEXT JMP,  >

% TERMINATE NUMBER CONVERSION
'#> CODE<  H POP,  #PTR LHLD,  XCHG,  #CNT LHLD,  DPUSH JMP,  >

% CONVERT A NUMBER AT TOP TO AN ASCII DIGIT
'#A CODE<  H POP,  -12 D LXI,  D DAD,  IFNC,  7 D LXI,  D DAD,  THEN,
  72 D LXI,  D DAD,  PUSH JMP,  >

% CONVERT NEXT DIGIT
'# : RADIX @ U/MOD #A #PUT ;

% CONVERT DIGITS UNTIL RESULT IS ZERO
'#S : BEGIN # DUP EQZ END ;

% UNSIGNED CONVERT
'U<#> : <# #S #> ;

% UNSIGNED CONVERT AND TYPE
'U= : U<#> TYPE SPACE ;

% TYPE UNSIGNED NUMBER ADDRESSED BY TOP
'U? : @ U= ;

% SIGNED NUMBER CONVERT
'<#> : DUP <L ABS <# #S L> LTZ IF 55 #PUT THEN #> ;

% SIGNED NUMBER CONVERT AND TYPE
'= : <#> TYPE SPACE ;

% TYPE SIGNED NUMBER ADDRESSED BY TOP
'? : @ = ;

% DEFINE ;:
';: : CONSTANT R> , ;CODE<  D PUSH,  XCHG,  H INX,  H INX,  M E MOV,
  H INX,  M D MOV,  .I LHLD,  XCHG,  .I SHLD,  .R LHLD,  H INX,  H INX,
  .R SHLD,  E M MOV,  H INX,  D M MOV,  H POP,  @PUSH JMP,  >

% ROUTINE: SZSTOIC BY WINK SAVILLE
% PURP:	DETERMINE THE # OF 256 BYTE PAGES USED BY STOIC
% ENTRY: NONE
% EXIT: THE MESSAGE
% 	STOIC IS XX DECIMAL PAGES LONG 
% 	WHERE XX IS THE # OF 256 BYTE PAGES

% FIRST CHANGE THE RADIX TO DECIMAL
DECIMAL

%
'SZSTOIC :
% SAVE PRESENT RADIX AND THEN CHANGE TO DECIMAL
RADIX @ DECIMAL
%
% TYPE OUT FIRST PART OF THE MESSAGE
"STOIC IS " MSG

% COMPUTE THE SIZE
. 256 / 1+ U=

% PRINT THE LAST PART OF THE MESSAGE
" DECIMAL PAGES LONG" MSG

% RESTORE OLD RADIX
RADIX !

;

;F



***EOF***
