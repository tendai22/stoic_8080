


% ***************************************************************************
% ** COPYRIGHT (C) MASSACHUSETTS INSTITUTE OF TECHNOLOGY AND HARVARD       **
% ** UNIVERSITY, BIOMEDICAL ENGINEERING CENTER 1977.  ALL RIGHTS RESERVED. **
% ***************************************************************************

% DOUBLE PRECISION INTEGER ARITHMETIC PACKAGE
% J. SACHS 3/4/77

% ON THE STACK, MOST SIGNIFICANT WORD IS AT TOP
% LEAST SIGNIFICANT WORD IS AT TOP - 1
%
% IN MEMORY, MOST SIGNIFICANT WORD IS AT ADDRESS
% LEAST SIGNIFICANT WORD IS AT ADDRESS + 2

RADIX @ OCTAL

% DOUBLE WORD STORE
'D! CODE<  H POP,  B POP,  D POP,  C M MOV,  H INX,  B M MOV,
  H INX,  E M MOV,  H INX,  D M MOV,  NEXT JMP, >

% DOUBLE WORD LOAD
'D@ CODE<  H POP,  M C MOV,  H INX,  M B MOV,  H INX,
  M E MOV,  H INX,  M D MOV,  D PUSH,  B PUSH,  NEXT JMP, >

% DOUBLE PRECISION LITERAL
'D() CODE<  .I LHLD,  H INX,  H INX,  M C MOV,  H INX,  M B MOV,  H INX,
  .I SHLD,  M E MOV,  H INX,  M D MOV,  D PUSH,  B PUSH,  NEXT JMP,  >

% DOUBLE WORD ADD
'D+ CODE<  H POP,  B POP,  D POP,  D DAD,  XCHG,  H POP,  B DAD,
  IFNC,  D INX,  THEN,  H PUSH,  D PUSH,  NEXT JMP,  >

% DOUBLE WORD NEGATE
'DMINUS CODE<  H POP,  D POP,  -HLDE CALL,  DPUSH JMP,  >

% DOUBLE WORD SUBTRACT
'D- : DMINUS D+ ;

% DOUBLE PRECISION CONSTANT AND VARIABLE DEFINITIONS
'DCONSTANT : CONSTANT , ;CODE<  XCHG,  () D@ 1+ JMP,  >
'DVARIABLE : VARIABLE , ;

% DOUBLE PRECISION ABSOLUTE VALUE
'DABS CODE<  H POP,  D POP,  H A MOV,  A ORA,  -HLDE CM,  DPUSH JMP,  >

% EXTEND SINGLE TO DOUBLE WORD
'EXTEND CODE<  D POP,  D PUSH,  D A MOV,  A ORA,  0PUSH JP,  -1PUSH JMP,  >

% DOUBLE PRECISIONS COMPARISONS WITH ZERO

'DEQZ CODE<  H POP,  D POP,  H A MOV,  .  L ORA,  D ORA,  E ORA,
  -1PUSH JZ,  0PUSH JMP,  >
'DLEZ CODE<  H POP,  D POP,  H A MOV,  A ORA,  -1PUSH JM,  JMP,  >

'DNEZ CODE<  H POP,  D POP,  H A MOV,  .  L ORA,  D ORA,  E ORA,
  0PUSH JZ,  -1PUSH JMP,  >
'DGTZ CODE<  H POP,  D POP,  H A MOV,  A ORA,  -1PUSH JP,  JMP,  >

'DLTZ CODE<  H POP,  D POP,  H A MOV,  A ORA,  -1PUSH JM,  0PUSH JMP,  >
'DGEZ CODE<  H POP,  D POP,  H A MOV,  A ORA,  -1PUSH JP,  0PUSH JMP,  >

% DOUBLE PRECISION COMPARISONS

'DEQ : D- DEQZ ;
'DNE : D- DNEZ ;
'DLT : D- DLTZ ;
'DLE : D- DLEZ ;
'DGE : D- DGEZ ;
'DGT : D- DGTZ ;

% DOUBLE PRECISION NUMBER CONVERSION PACKAGE

% DIVIDE DOUBLE PRECISION NUMBER BY SINGLE PRECISION NUMBER
% YIELDING A DOUBLE PRECISION QUOTIENT AND A SINGLE PRECISION REMAINDER
'UE/MOD : DUP <L U/MOD 2SWAP L> UM/MOD 2SWAP ;

% INITIATE AND TERMINATE NUMBER CONVERSION
'D<# : <# ;
'D#> : DROP #> ;

% CONVERT NEXT DIGIT
'D# : RADIX @ UE/MOD #A #PUT ;

% CONVERT DIGITS UNTIL RESULT IS ZERO
'D#S : BEGIN D# DDUP DEQZ END ;

% UNSIGNED CONVERT
'DU<#> : D<# D#S D#> ;

% UNSIGNED CONVERT AND TYPE
'DU= : DU<#> TYPE SPACE ;

% TYPE UNSIGNED NUMBER ADDRESSED BY TOP
'DU? : D@ DU= ;

% SIGNED NUMBER CONVERT
'D<#> : DDUP <L <L DABS D<# D#S L> L> DLTZ IF 55 #PUT THEN D#> ;

% SIGNED NUMBER CONVERT AND TYPE
'D= : D<#> TYPE SPACE ;

% TYPE SIGNED NUMBER ADDRESSED BY TOP
'D? : D@ D= ;

% DOUBLE PRECISION LITERAL PROCESSOR

. ASSEMBLER<
  T1 4 + LHLD,  M A MOV,  H INX,  T1 4 + SHLD,  RET,
'LITG CONSTANT

'DILITERAL CODE<
  H POP,  H INX,  T1 4 + SHLD,  0 H LXI,  T1 2 + SHLD,  T1 6 + SHLD,
  T1 10 + SHLD,  LITG CALL,  104 CPI,  0PUSH JNZ,
  LITG CALL,  53 CPI,  IFZ,  55 CPI,  IFNZ,  -1 H LXI,  T1 2 + SHLD,
  . <L SWAP THEN,

  LITG CALL, THEN,  A ORA,  IFZ,  60 SUI,
  0PUSH JC,  12 CPI,  IFC,  21 CPI,  0PUSH JC,  7 SUI,  THEN,
  RADIX LHLD,  L CMP,  0PUSH JNC,  T1 STA,

  RADIX LHLD,  XCHG,  T1 6 + LHLD,  MUL CALL,  T1 12 + SHLD,  XCHG,
  T1 6 + SHLD,  RADIX LHLD,  XCHG,  T1 10 + LHLD,  MUL CALL,  H A MOV,
  L ORA,  0PUSH JNZ,  T1 12 + LHLD,  D DAD,  0PUSH JC,  T1 10 + SHLD,

  T1 LDA,  A L MOV,  0 H MVI,  XCHG,  T1 6 + LHLD,  D DAD,
  T1 6 + SHLD,  IFNC,  T1 10 + LHLD,  H INX,  T1 10 + SHLD,
  THEN,  L> JMP,

  THEN,  T1 2 + LHLD,  H A MOV,  A ORA,  T1 6 + LHLD,
  XCHG,  T1 10 + LHLD,  -HLDE CM,  D PUSH,  H PUSH,  -1PUSH JMP,  >

% CAUSE COMPILER TO PROCESS DOUBLE PRECISION LITERALS
'DILIT : // LIT @ C, // IF
  -1 ELSE . DILITERAL IF () D() C, C, C, -1 ELSE 0 THEN THEN ;
() DILIT LIT !

D-1 'D-1 DCONSTANT
D0 'D0 DCONSTANT
D1 'D1 DCONSTANT

RADIX !
;F



***EOF***

