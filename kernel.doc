




***************************************************************************
** COPYRIGHT (C) MASSACHUSETTS INSTITUTE OF TECHNOLOGY AND HARVARD       **
** UNIVERSITY, BIOMEDICAL ENGINEERING CENTER 1977.  ALL RIGHTS RESERVED. **
***************************************************************************

THE STOIC KERNEL
J. SACHS
3/3/77

	THE KERNEL IS A COLLECTION OF WORDS WHICH DEFINE
STOIC ITSELF AND WHICH MAKE FURTHER DEFINITIONS POSSIBLE.
THE FOLLOWING IS A COMPLETE LIST OF THE WORDS IN THE
KERNEL ALONG WITH DESCRIPTIONS OF THEIR ACTION.  ANY OF
THESE WORDS MAY BE CALLED BY THE USER ALTHOUGH SOME
OF THEM ARE HIGHLY SPECIALIZED.

VARIABLES

NAME	DESCRIPTION

STATE	ZERO FOR EXECUTE (BYTE VARIABLE)
	NONZERO FOR COMPILE

CURRENT	DICTIONARY HEAD FOR NEW DEFINITIONS

.C	COMPILE BUFFER POINTER

.D	CURRENT POINTER TO END OF DICTIONARY

.I	PSEUDO-INSTRUCTION POINTER

.R	RETURN STACK POINTER

.L	LOOP STACK POINTER

.V	VOCABULARY STACK POINTER

RADIX	CURRENT NUMBER CONVERSION RADIX

CHECK	NESTING DEPTH COUNTER (BYTE VARIABLE)

IN	CURRENT INPUT ROUTINE

OUT	CURRENT OUTPUT ROUTINE

PROMPT	ADDRESS OF PROMPT WORD

ERRMSG	ADDRESS OF ERROR MESSAGE HANDLER

COLUMN	OUTPUT COLUMN # (BYTE VARIABLE)

FCT	FILE CONTROL TABLE POINTER

MEMORY	TOP OF RAM

LIT	ADDRESS OF LITERAL HANDLER

(TTYIN)	ADDRESS OF TTY INPUT ROUTINE

(TTYOU)	ADDRESS OF TTY OUTPUT ROUTINE

(ABORT)	ADDRESS OF ROUTINE CALLED EVERY TIME "ABORT" IS INVOKED


THE KERNEL CONTAINS THE FOLLOWING CONSTANTS:

NAME	VALUE

-1	-1

0	0

1	1

2	2


	NEXT FOLLOWS A LIST OF THE BASIC STOIC
VOCABULARY.  THE COLUMN LABELLED "ARGS" GIVES THE
NUMBER OF ARGUMENTS EXPECTED ON THE STACK FOLLOWED
BY THE NUMBER OF RESULTS RETURNED ON THE STACK.  AN
ASTERISK IN THIS COLUMN INDICATES THAT THE PRECEDENCE
BIT FOR THE CORRESPONDING DICTIONARY ENTRY IS SET.


LITERAL HANDLING WORDS
NAME	ARGS	DESCRIPTION

()	0/1	PUSH THE CONTENTS OF THE LOCATION
		POINTED TO BY ".I".  INCREMENT ".I"

S()	0/1	PUSH THE ADDRESS OF THE STRING LITERAL
		IMMEDIATELY FOLLOWING.  IT GETS THE NEXT
		WORD, EXTRACTS THE LENGTH, AND INCREMENTS
		".I" TO POINT TO THE FIRST WORD FOLLOWING
		THE STRING.  THE ADDRESS OF THE FIRST WORD
		OF THE STRING IS LEFT ON THE STACK.


ERROR HANDLING WORDS
NAME	ARGS	DESCRIPTION

ABORT	N/0	THIS IS A GENERAL GARBAGE COLLECTION ROUTINE
		WHICH ABORTS WHATEVER ACTION IS
		CURRENTLY BEING TAKEN AND RETURNS
		CONTROL TO THE KEYBOARD.

ERR	1/0	EXECUTES THE CONTENTS OF THE WORD "ERRMSG".

ERRCH	0/0	CHECKS FOR THE ERROR CONDITIONS:

		LOOP STACK EMPTY/FULL
		VOCABULARY STACK EMPTY/FULL
		DICTIONARY FULL
		COMPILE BUFFER FULL

		IF AN ERROR CONDITION EXISTS, EXECUTE
		"ERR" WITH THE APPROPRIATE MESSAGE.
		OTHERWISE RETURN.


STACK MANIPULATION WORDS
NAME	ARGS	DESCRIPTION

S@	0/1	PUSH THE CONTENTS OF THE STACK POINTER

<R	1/0	PUSH TOP ON RETURN STACK

R>	0/1	POP TOP FROM RETURN STACK

<L	1/0	PUSH TOP ON LOOP STACK

L>	0/1	POP TOP FROM LOOP STACK


NAME	ARGS	BEFORE	AFTER

DUP	1/2	A	A
			A

OVER	2/3	A	B
		B	A
			B

2OVER	3/4	A	C
		B	A
		C	B
			C

3OVER	4/5	A	D
		B	A
		C	B
		D	C
			D

UNDER	2/1	A	A
		B

2UNDER	3/2	A	B
		B	A
		C

3UNDER	4/3	A	B
		B	C
		C	A
		D

SWAP	2/2	A	B
		B	A

2SWAP	3/3	A	A
		B	C
		C	B

FLIP	3/3	A	C
		B	B
		C	A

DROP	1/0	A	B
		B

2DROP	2/0	A	C
		B
		C

3DROP	3/0	A	D
		B
		C
		D

DDUP	2/4	A	A
		B	B
			A
			B

DOVER	4/6	A	C
		B	D
		C	A
		D	B
			C
			D

DUNDER	4/2	A	A
		B	B
		C
		D

DSWAP	4/4	A	C
		B	D
		C	A
		D	B

-ROT	3/3	A	C
		B	A
		C	B

+ROT	3/3	A	B
		B	C
		C	A


LOAD AND STORE WORDS
NAME	ARGS	DESCRIPTION

@	1/1	REPLACES ADDRESS AT TOP WITH ITS
		CONTENTS

!	2/0	STORES NUMBER AT TOP - 1 IN ADDRESS AT
		TOP.

<-	2/0	STORE WORD ON TOP IN LOCATION
		ADDRESSED BY TOP - 1

@@	1/1	LOAD INDIRECT TOP

@!	2/0	STORE TOP - 1 INDIRECT ADDRESS AT TOP

+!	2/0	ADD TOP - 1 TO CONTENTS OF LOCATION
		ADDRESSED BY TOP

1+!	1/0	INCREMENT LOCATION ADDRESSED BY TOP

1-!	1/0	DECREMENT LOCATION ADDRESSED BY TOP

0<-	1/0	ZERO LOCATION ADDRESSED BY TOP

-1<-	1/0	SET TO -1 LOCATION ADDRESSED BY TOP

MOVE	2/0	THE CONTENTS OF THE LOCATION ADDRESSED
		BY TOP - 1 IS STORED A THE LOCATION
		GIVEN BY TOP.

XCHG	2/0	THE CONTENTS OF TWO WORDS ADDRESSED BY
		TOP AND TOP - 1 ARE INTERCHANGED.

B@	1/1	LOAD BYTE ADDRESSED BY BYTE POINTER ON
		TOP OF STACK

B!	2/0	STORE BYTE AT TOP - 1 AT BYTE ADDRESS
		ON TOP OF STACK

FILL	3/0	STORE N COPIES OF DATA AT TOP AT ADDRESS
		AT TOP-2 WHERE N IS AT TOP-1.

0FILL	2/0	STORE N ZEROS AT ADDRESS AT TOP-1 WHERE N
		IS AT TOP.
		
MVBYTES	3/0	COPY N BYTES FROM LOCATION A TO LOCATION
		B.  N IS TOP OF STACK, B IS TOP - 1, AND
		A IS TOP - 2.  (A AND B ARE BYTE POINTERS)
		A AND B RUN FORWARDS.

RMVBYTES 3/0	COPY N BYTES FROM LOCATION A TO LOCATION
		B.  N IS TOP OF STACK, B IS TOP - 1, AND
		A IS TOP - 2.  (A AND B ARE BYTE POINTERS)
		A AND B RUN BACKWARDS.


UNARY OPERATORS
NAME	ARGS	DESCRIPTION

MINUS	1/1	NEGATES TOP

NOT	1/1	COMPLEMENTS TOP

2*	1/1	SHIFT TOP LEFT 1

2/	1/1	SHIFT TOP RIGHT 1 (SIGNED)

U2/	1/1	SHIFT TOP RIGHT 1 (UNSIGNED)

EXEC	1/0	EXECUTE WORD WHOSE ADDRESS IS AT TOP

1+	1/1	INCREMENT TOP

1-	1/1	DECREMENT TOP

2+	1/1	INCREMENT TOP BY 2

2-	1/1	DECREMENT TOP BY 2

ABS	1/1	TAKE ABSOLUTE VALUE OF TOP

EQZ	1/1	IF TOP EQUALS 0, PUSH -1
		OTHERWISE PUSH 0

LTZ	1/1	IF TOP LESS THAN 0, PUSH -1
		OTHERWISE PUSH 0

GTZ	1/1	IF TOP GREATER THAN 0, PUSH -1
		OTHERWISE PUSH 0

NEZ	1/1	IF TOP NOT EQUAL TO 0, PUSH -1
		OTHERWISE PUSH 0

LEZ	1/1	IF TOP LESS OR EQUAL TO 0, PUSH -1
		OTHERWISE PUSH 0

GEZ	1/1	IF TOP GREATER OR EQUAL TO 0, PUSH -1
		OTHERWISE PUSH 0


BINARY OPERATORS
NAME	ARGS	DESCRIPTION

+	2/1	ADDS TOP AND TOP - 1

-	2/1	SUBTRACTS TOP FROM TOP - 1

AND	2/1	ANDS TOP AND TOP - 1

OR	2/1	ORS TOP AND TOP - 1

XOR	2/1	XORS TOP AND TOP - 1

MAX	2/1	MAXIMUM OF TOP AND TOP - 1 (SIGNED)

MIN	2/1	MINIMUM OF TOP AND TOP - 1 (SIGNED)

UMAX	2/1	MAXIMUM OF TOP AND TOP - 1 (UNSIGNED)

UMIN	2/1	MINIMUM OF TOP AND TOP - 1 (UNSIGNED)

LSHIFT	2/1	SHIFT WORD AT TOP - 1 LEFT A NUMBER
		OF BIT POSITIONS ON TOP OF STACK

RSHIFT	2/1	SHIFT WORD AT TOP - 1 RIGHT A NUMBER
		OF BIT POSITIONS ON TOP OF STACK
		(SIGNED)

URSHIFT	2/1	SHIFT WORD AT TOP - 1 RIGHT A NUMBER
		OF BIT POSITIONS ON TOP OF STACK
		(UNSIGNED)

DLSHIFT	3/2	32-BIT LEFT SHIFT THE NUMBER AT TOP - 1
		AND TOP - 2 A NUMBER OF PLACES GIVEN BY
		TOP.

DRSHIFT	3/2	32-BIT RIGHT SHIFT THE NUMBER AT TOP - 1
		AND TOP - 2 A NUMBER OF PLACES GIVEN BY
		TOP.  (SIGNED)

DURSHIFT 3/2	32-BIT RIGHT SHIFT THE NUMBER AT TOP - 1
		AND TOP - 2 A NUMBER OF PLACES GIVEN BY
		TOP.  (UNSIGNED)

EQ	2/1	IF TOP EQUALS TOP - 1, PUSH -1
		OTHERWISE PUSH 0

NE	2/1	IF TOP NOT EQUAL TO TOP - 1, PUSH -1
		OTHERWISE PUSH 0

LT	2/1	IF TOP LESS THAN TOP - 1, PUSH -1
		OTHERWISE PUSH 0 (SIGNED)

GT	2/1	IF TOP GREATER THAN TOP - 1, PUSH -1
		OTHERWISE PUSH 0 (SIGNED)

LE	2/1	IF TOP LESS OR EQUAL THAN TOP - 1,
		PUSH -1, OTHERWISE PUSH 0 (SIGNED)

GE	2/1	IF TOP GREATER OR EQUAL THAN TOP - 1,
		PUSH -1, OTHERWISE PUSH 0 (SIGNED)

ULT	2/1	IF TOP LESS THAN TOP - 1, PUSH -1
		OTHERWISE PUSH 0 (UNSIGNED)

UGT	2/1	IF TOP GREATER THAN TOP - 1, PUSH -1
		OTHERWISE PUSH 0 (UNSIGNED)

ULE	2/1	IF TOP LESS OR EQUAL THAN TOP - 1,
		PUSH -1, OTHERWISE PUSH 0 (UNSIGNED)

UGE	2/1	IF TOP GREATER OR EQUAL THAN TOP - 1,
		PUSH -1, OTHERWISE PUSH 0 (UNSIGNED)


MIXED PRECISION OPERATORS

M+	3/2	ADD THE SINGLE PRECISION NUMBER AT TOP
		TO THE DOUBLE PRECISION NUMBER
		(TOP-1,TOP-2) GIVING A DOUBLE PRECISION
		RESULT.

M-	3/2	SUBTRACT THE SINGLE PRECISION NUMBER AT
		TOP FROM THE DOUBLE PRECISION NUMBER
		(TOP-1,TOP-2) GIVING A DOUBLE PRECISION
		RESULT.


MULTIPLY AND DIVIDE WORDS
OVERFLOW DOES NOT GENERATE ERROR MESSAGE

UNSIGNED OPERATIONS
NAME	ARGS	DESCRIPTION

UM*	2/2	UNSIGNED MULTIPLY WITH 32-BIT RESULT

U/MOD	2/2	UNSIGNED INTEGER DIVIDE, (TOP-1)/TOP
		REMAINDER ON TOP, QUOTIENT AT TOP - 1

UM/MOD	3/2	UNSIGNED DIVIDE, (TOP-1,TOP-2)/TOP
		REMAINDER ON TOP, QUOTIENT AT TOP - 1

U*	2/1	UNSIGNED MULTIPLY

U/	2/1	UNSIGNED INTEGER DIVIDE

UMOD	2/1	UNSIGNED REMAINDER

UM/	3/1	UNSIGNED DIVIDE

U*/MOD	3/2	UNSIGNED (TOP-2)*(TOP-1)/TOP (32 BIT
		INTERMEDIATE PRODUCT) REMAINDER AT TOP,
		QUOTIENT AT TOP - 1

U*/	3/1	UNSIGNED (TOP-2)*(TOP-1)/TOP (32 BIT
		INTERMEDIATE PRODUCT)

SIGNED OPERATIONS
NAME	ARGS	DESCRIPTION

M*	2/2	SIGNED MULTIPLY TOP - 1 BY TOP
		WITH 32-BIT RESULT

/MOD	2/2	SIGNED DIVIDE TOP - 1 BY TOP
		LEAVING REMAINDER AT TOP,
		QUOTIENT AT TOP - 1.

M/MOD	3/2	SIGNED DIVIDE, (TOP-1,TOP-2)/TOP
		REMAINDER ON TOP, QUOTIENT AT TOP - 1

*	2/1	SIGNED MULTIPLY

/	2/1	SIGNED INTEGER DIVIDE

MOD	2/1	SIGNED REMAINDER

M/	3/1	SIGNED DIVIDE

*/	3/1	SIGNED (TOP-2)*(TOP-1)/TOP (32 BIT
		INTERMEDIATE PRODUCT)

*/MOD	3/2	SIGNED (TOP-2)*(TOP-1)/TOP (32 BIT
		INTERMEDIATE PRODUCT) REMAINDER AT TOP,
		QUOTIENT AT TOP - 1


DICTIONARY MANIPULATING WORDS
NAME	ARGS	DESCRIPTION

.	0/1	PUSH VALUE OF DICTIONARY POINTER (".D")

C.	0/1	PUSH VALUE OF COMPILE BUFFER POINTER (".C")

,	1/0	STORE TOP AT END OF DICTIONARY,
		INCREMENT ".D".

C,	1/0	STORE TOP AT END OF COMPILE BUFFER,
		INCREMENT ".C".

B,	1/0	STORES A BYTE AT END OF DICTIONARY

CB,	1/0	STORES A BYTE AT END OF COMPILE BUFFER

IMMEDIATE 0/0	SET PRECEDENCE BIT OF MOST RECENTLY
		DEFINED WORD (FOUND VIA "CURRENT").

ENTER	1/0	STRING ARGUMENT ON STACK.  FIRST
		VERIFIES THAT THE NAMED WORD IS UNDEFINED.
		IF DEFINED TYPES WARNING "REDEFINING"
		FOLLOWED BY STRING.  THE NAME IS COPIED
		ONTO THE END OF THE DICTIONARY, THE NEW
		ENTRY IS LINKED IN, AND A ($+2) IS
		STORED AS THE CODE ADDRESS.

ASSEMBLER< 0/0	PUSH ADDRESS OF "ASSEMBLER<" ON VOCABULARY STACK.

STOIC<	0/0	PUSH ADDRESS OF "STOIC<" ON VOCABULARY STACK.

>	0/0	DISCARDS THE TOP OF THE VOCABULARY STACK

DEFINITIONS 1/0	COPIES THE TOP OF THE VOCABULARY STACK INTO "CURRENT".

BRANCH	1/0	CREATE NEW VOCABULARY DISJOINT FROM
		DICTIONARY.  GET VOCABULARY NAME FROM
		STRING ARGUMENT.

FORGET	1/0	LOOK UP STRING ARGUMENT IN DICTIONARY
		AND DISCARD IT AND ALL MORE RECENT
		DICTIONARY ENTRIES.

//	0/0*	COMPLEMENT "STATE"

(:)	0/0	ANONYMOUS DICTIONARY ENTRY WHICH
		PUSHES ".I" ON THE RETURN STACK AND
		SETS ".I" TO 2 LESS THAN THE ADDRESS
		OF THE FIRST WORD OF THE PARAMETER
		FIELD OF THE CURRENTLY EXECUTING WORD.

((:))	0,0	ANONYMOUS DICTIONARY ENTRY WHICH
		GETS NEXT WORD VIA ".I" AND COPIES
		THAT MANY BYTES FROM THE PSEUDO-
		INSTRUCTION STREAM INTO THE DICTIONARY.
		BOTH ".I" AND ".D" ARE UPDATED.

:	0/0*	GIVES "SYNTAX ERROR" IF CHECK IS NOT
		ZERO, INCREMENTS CHECK, OUTPUT ADDRESS
		OF ENTER TO COMPILE BUFFER, OUTPUT
		ADDRESS OF ((:)) TO COMPILE BUFFER,
		PUSH THE CONTENTS OF .C, OUTPUT A ZERO
		TO THE COMPILE BUFFER.

CODE<	0/0*	OUTPUT ADDRESS OF "ENTER" TO COMPILE
		BUFFER, PUSH THE ADDRESS OF "ASSEMBLER<"
		ON THE VOCABULARY STACK.

(;)	0/0	ANONYMOUS DICTIONARY ENTRY WHICH POPS
		".I" OFF THE RETURN STACK.

;	0/0*	DECREMENT CHECK, GIVE "SYNTAX ERROR" IF
		NOT ZERO, TERMINATE ":", OUTPUT ADDRESS
		OF (;) TO COMPILE BUFFER.

(;CODE<) 0/0	ANONYMOUS DICTIONARY ENTRY WHICH
		STORES (CONTENTS OF ".I")+1 IN THE CODE
		ADDRESS WORD OF THE MOST RECENTLY
		DEFINED WORD.

;CODE<	0/0*	DECREMENT CHECK, GIVE "SYNTAX ERROR" IF
		NOT ZERO, TERMINATE ":", OUTPUT ADDRESS OF
		(;CODE<) TO COMPILE BUFFER, PUSH ADDRESS OF
		"ASSEMBLER<" ON VOCABULARY STACK.

(CONSTANT) 0/1	PUSH CONTENTS OF PARAMETER FIELD.

CONSTANT 2/0	EXECUTE "ENTER", OUTPUT TOP - 1
		DICTIONARY, SET UP (CONSTANT) AS CODE
		ADDRESS.

(VARIABLE) 0/1	PUSH ADDRESS OF PARAMETER FIELD.

VARIABLE 2/0	EXECUTE "CONSTANT", SET UP (VARIABLE)
		AS CODE ADDRESS.

ARRAY	2/0	2ND ARGUMENT IS NAME OF ARRAY.  AN INITIALLY
		ZERO VARIABLE IS CREATED AND N-1 ZEROS
		ARE OUTPUT TO THE DICTIONARY WHERE N IS
		THE 1ST ARGUMENT.

(;:)	0/1	PUSH ".I" ON RETURN STACK, SET ".I"
		TO THE CONTENTS OF THE 2ND WORD OF THE
		PARAMETER FIELD, DECREMENT ".I" BY 2.

;:	0/0	EXECUTE "CONSTANT", POP RETURN STACK
		AND OUTPUT TOP OF RETURN STACK TO
		DICTIONARY, SET UP (;:) AS CODE ADDRESS.


HIGHER LEVEL COMPILER WORDS
NAME	ARGS	DESCRIPTION

+CHECK	0/0	INCREMENTS "CHECK"

-CHECK	0/0	DECREMENTS "CHECK"; IF RESULT IS MINUS,
		THE ERROR "SYNTAX ERROR" IS GIVEN.

(IF)	1/0	TESTS TOP.  IF ZERO, ".I" IS INCREMENTED.
		OTHERWISE, ".I" IS INCREMENTED BY THE CONTENTS
		OF THE NEXT SEQUENTIAL WORD AND
		INCREMENTS ".I".

(ELSE)	1/0	INCREMENTS ".I" BY THE CONTENTS OF THE NEXT
		SEQUENTIAL WORD.

(()	1/0	DECREMENTS THE TOP OF THE STACK.  IF NEGATIVE
		OR ZERO, ".I" IS INCREMENTED BY THE CONTENTS OF THE
		NEXT SEQUENTIAL WORD.  OTHERWISE, THE
		LOOP STACK POINTER IS INCREMENTED TWICE,
		THE TOP OF THE STACK IS PUSHED ON THE LOOP
		STACK, AND ".I" IS INCREMENTED.

(U()	1/0	DECREMENTS THE TOP OF THE STACK.  IF ZERO,
		".I" IS INCREMENTED BY THE CONTENTS OF THE
		NEXT SEQUENTIAL WORD.  OTHERWISE, THE
		LOOP STACK POINTER IS INCREMENTED TWICE,
		THE TOP OF THE STACK IS PUSHED ON THE LOOP
		STACK, AND ".I" IS INCREMENTED.

())	0/0	DECREMENTS THE WORD ON THE TOP OF
		THE LOOP STACK.  IF THE RESULT IS
		ZERO, THE LOOP STACK IS POPPED 3 TIMES
		AND ".I" IS INCREMENTED.  OTHERWISE, ".I"
		IS INCREMENTED BY THE CONTENTS OF THE NEXT
		SEQUENTIAL WORD.

(DO)	2/0	TESTS IF TOP IS GREATER OR EQUAL TOP-1
		IF GREATER OR EQUAL, ".I" IS INCREMENTED
		BY THE CONTENTS OF THE NEXT SEQUENTIAL WORD.
		IF NOT, TOP-1 IS PUSHED ON THE LOOP
		STACK FOLLOWED BY TWO COPIES OF TOP,
		AND ".I" IS INCREMENTED.  (SIGNED)

(LOOP)	0/0	INCREMENTS THE TOP OF THE LOOP STACK
		AND COMPARES THE RESULT WITH TOP-2
		OF THE LOOP STACK.  IF GREATER OR EQUAL,
		POP THE LOOP STACK 3 TIMES AND INCREMENT
		".I".  OTHERWISE ".I" IS INCREMENTED BY THE
		CONTENTS OF THE NEXT SEQUENTIAL WORD.
		(SIGNED)

(+LOOP)	 1/0	ADDS THE TOP OF THE STACK TO THE TOP
		OF THE LOOP STACK.  OTHERWISE THE SAME
		AS "LOOP".  (SIGNED)

(UDO)	2/0	TESTS IF TOP IS GREATER OR EQUAL TOP-1
		IF GREATER OR EQUAL, ".I" IS INCREMENTED
		BY THE CONTENTS OF THE NEXT SEQUENTIAL WORD.
		IF NOT, TOP-1 IS PUSHED ON THE LOOP
		STACK FOLLOWED BY TWO COPIES OF TOP,
		AND ".I" IS INCREMENTED.  (UNSIGNED)

(ULOOP)	0/0	INCREMENTS THE TOP OF THE LOOP STACK
		AND COMPARES THE RESULT WITH TOP-2
		OF THE LOOP STACK.  IF GREATER OR EQUAL,
		POP THE LOOP STACK 3 TIMES AND INCREMENT
		".I".  OTHERWISE ".I" IS INCREMENTED BY THE
		CONTENTS OF THE NEXT SEQUENTIAL WORD.
		(UNSIGNED)

(U+LOOP) 1/0	ADDS THE TOP OF THE STACK TO THE TOP
		OF THE LOOP STACK.  OTHERWISE THE SAME
		AS "ULOOP".  (UNSIGNED)

BEGIN	0/1*	EXECUTE +CHECK, PUSH (CONTENTS OF .C) - 2

END	1/0*	EXECUTE -CHECK, OUTPUT ADDRESS OF (IF) TO
		COMPILE BUFFER, TERMINATE "BEGIN".

REPEAT	2/0*	EXECUTE -CHECK TWICE, OUTPUT ADDRESS OF (ELSE)
		TO COMPILE BUFFER, TERMINATE "BEGIN" AND "IF".

IF	0/1*	EXECUTE +CHECK, OUTPUT ADDRESS OF (IF) TO
		COMPILE BUFFER, PUSH CONTENTS OF ".C", OUTPUT
		A ZERO TO THE COMPILE BUFFER.

THEN	1/0*	EXECUTE -CHECK, TERMINATE "IF".

ELSE	1/1*	EXECUTE -CHECK, EXECUTE +CHECK, OUTPUT ADDRESS
		OF (ELSE) TO COMPILE BUFFER,  TERMINATE "IF",
		PUSH CONTENTS OF .C, OUTPUT A ZERO TO THE
		COMPILE BUFFER.

(	0/1*	EXECUTE +CHECK, OUTPUT ADDRESS OF (() TO
		THE COMPILE BUFFER.  PUSH CONTENTS OF ".C",
		OUTPUT A ZERO TO THE COMPILE BUFFER.

U(	0/1*	EXECUTE +CHECK, OUTPUT ADDRESS OF (U() TO
		THE COMPILE BUFFER.  PUSH CONTENTS OF ".C",
		OUTPUT A ZERO TO THE COMPILE BUFFER.

)	1/0*	EXECUTE -CHECK, OUTPUT ADDRESS OF ()) TO
		THE COMPILE BUFFER, TERMINATE "(".

DO	0/1*	EXECUTE +CHECK, OUTPUT ADDRESS OF (DO) TO
		THE COMPILE BUFFER.  PUSH CONTENTS OF ".C",
		OUTPUT A ZERO TO THE COMPILE BUFFER.

LOOP	1/0*	EXECUTE -CHECK, OUTPUT ADDRESS OF (LOOP) TO
		THE COMPILE BUFFER, TERMINATE "DO".
		
+LOOP	1/0*	EXECUTE -CHECK, OUTPUT ADDRESS OF (+LOOP) TO
		THE COMPILE BUFFER, TERMINATE "DO".
		
UDO	0/1*	EXECUTE +CHECK, OUTPUT ADDRESS OF (UDO) TO
		THE COMPILE BUFFER.  PUSH CONTENTS OF ".C",
		OUTPUT A ZERO TO THE COMPILE BUFFER.

ULOOP	1/0*	EXECUTE -CHECK, OUTPUT ADDRESS OF (ULOOP) TO
		THE COMPILE BUFFER, TERMINATE "DO".
		
U+LOOP	1/0*	EXECUTE -CHECK, OUTPUT ADDRESS OF (U+LOOP) TO
		THE COMPILE BUFFER, TERMINATE "DO".
		
I	0/1	PUSH COPY OF TOP OF LOOP STACK

J	0/1	PUSH COPY OF TOP - 3 OF LOOP STACK

K	0/1	PUSH COPY OF TOP - 6 OF LOOP STACK
		
I'	0/1	PUSH (TOP-2)+(TOP-1)-(TOP)-1 OF LOOP STACK

J'	0/1	PUSH (TOP-5)+(TOP-4)-(TOP-3)-1 OF LOOP STACK

K'	0/1	PUSH (TOP-8)+(TOP-7)-(TOP-6)-1 OF LOOP STACK

EXIT	0/0	SET TOP AND TOP - 2 OF LOOP STACK TO 1.


CHARACTER ORIENTED I/O WORDS
NAME	ARGS	DESCRIPTION

IN	0/1	VARIABLE CONTAINING ADDRESS OF INPUT WORD

OUT	0/1	VARIABLE CONTAINING ADDRESS OF OUTPUT WORD

<TTI>	0/1	READS A BYTE FROM THE TTY KEYBOARD.
		THE BYTE IS NOT ECHOED.

<TTO>	1/0	OUTPUT A BYTE TO THE TTY PRINTER.
		COLUMN IS INCREMENTED.
		IF THE CHAR IS A CR, A LF IS OUTPUT AND COLUMN IS ZEROED
		IF THE CHAR IS A TAB, SPACES ARE OUTPUT UNTIL COLUMN = 0 MOD 8

TYO	1/0	EXECUTE CONTENTS OF "OUT".

TYI	0/1	EXECUTE CONTENTS OF "IN".

SPACE	0/0	OUTPUT A SPACE.

SPACES	1/0	OUTPUT N SPACES.

CR	0/0	OUTPUT A CARRIAGE RETURN

TAB	1/0	TAB TO COLUMN N.  NO ACTION TAKEN IF COLUMN
		GREATER OR EQUAL N.

COUNT	1/2	GIVEN A POINTER AT TOP, RETURNS CONTENTS OF
		BYTE ADDRESSED BY POINTER AT TOP, VALUE OF
		POINTER + 1 AT TOP - 1.

TYPE	2/0	OUTPUT A STRING; BYTE COUNT ON TOP AND
		BYTE POINTER AT TOP - 1.  (USES TYO)

RDLINE	0/0	READS AN INPUT LINE INTO THE KEYBOARD BUFFER.
		IF INBLK IS -1, THE LINE IS ACCEPTED FROM THE
		KEYBOARD; OTHERWISE INBLK,INBYTE POINTS TO THE
		BLOCK AND BYTE ON THE MASS STORAGE DEVICE FROM
		WHICH INPUT IS TAKEN.  INBLK AND INBYTE ARE
		UPDATED.  THE LINE IS NULL TERMINATED AND
		PRECEDED BY A BYTE COUNT.  IF EXECUTING FROM THE
		KEYBOARD, RUBOUT, NULL, AND LINE FEED ARE PROCESSED.
		LINE IS TERMINATED BY CR OR FF.  IF KEYBOARD BUFFER
		OVERFLOWS, THE ERROR "KEYBOARD BUFFER FULL" IS GIVEN.


NUMBER OUTPUT CONVERSION WORDS
NAME	ARGS	DESCRIPTION

#CNT	0/1	VARIABLE CONTAINING LENGTH OF CONVERTED STRING

#PTR	0/1	VARIABLE CONTAINING POINTER TO CONVERTED STRING

<#	0/0	INITIALIZE #CNT TO 0, INITIALIZE #PTR TO
		POINT 40 (OCTAL) BYTES PAST THE CURRENT END OF
		THE DICTIONARY.

#PUT	1/0	DECREMENT #PTR, STORE BYTE INDIRECT #PTR
		INCREMENT #CNT.

#A	1/1	CONVERT TO NUMBER AT TOP TO AN ASCII
		DIGIT.

#	1/1	DIVIDE THE NUMBER ON THE TOP OF THE STACK
		BY RADIX, LEAVING THE QUOTIENT ON THE TOP
		OF THE STACK.  CONVERT THE REMAINDER TO
		AN ASCII DIGIT AND OUTPUT IT VIA #PUT.

#S	1/1	EXECUTE # REPEATEDLY UNTIL THE TOP OF THE
		STACK IS ZERO.  # IS ALWAYS EXECUTED AT
		LEAST ONCE.

#>	1/2	DISCARD THE TOP OF THE STACK, PUSH THE CONTENTS
		OF #PTR, PUSH THE CONTENTS OF #CNT.

<#>	1/2	CONVERT THE NUMBER ON THE TOP OF THE STACK
		TO A STRING.  LEAVE THE BYTE COUNT ON THE TOP
		OF THE STACK, THE BYTE POINTER AT TOP - 1.
		(SIGNED)

U<#>	1/2	CONVERT THE NUMBER ON THE TOP OF THE STACK
		TO A STRING.  LEAVE THE BYTE COUNT ON THE TOP
		OF THE STACK, THE BYTE POINTER AT TOP - 1.
		(UNSIGNED)

U=	1/0	CONVERT THE NUMBER ON THE TOP OF THE
		STACK TO A STRING AND TYPE IT.
		(UNSIGNED)

U?	1/0	TYPE THE CONTENTS OF THE LOCATION
		ADDRESSED BY THE TOP OF THE STACK.
		(UNSIGNED)

=	1/0	CONVERT THE NUMBER ON THE TOP OF THE
		STACK TO A STRING AND TYPE IT.

?	1/0	TYPE THE CONTENTS OF THE LOCATION
		ADDRESSED BY THE TOP OF THE STACK.

OCTAL	0/0	SET RADIX TO OCTAL

DECIMAL	0/0	SET RADIX TO DECIMAL

HEX	0/0	SET RADIX TO HEXADECIMAL


BUFFER HANDLING WORDS

	STOIC MAINTAINS A POOL OF SYSTEM BUFFERS WHICH ARE
USED TO HOLD BLOCKS FROM THE STORAGE MEDIUM IN MEMORY.  THEY
ARE ALLOCATED USING A "LEAST RECENTLY USED" ALGORITHM.

RBLOCK	1/1
	RETURNS THE ADDRESS OF A BUFFER CONTAINING THE BLOCK
	WHOSE NUMBER IS AT TOP.  WHEN A BLOCK IS REQUESTED USING
	"RBLOCK", IF THE SPECIFIED BLOCK IS ALREADY IN MEMORY,
	ITS ADDRESS IS IMMEDIATELY RETURNED.  IF IT IS NOT IN
	MEMORY, THE LEAST RECENTLY USED BUFFER IS FREED (I.E.
	WRITTEN OUT IF MODIFIED), AND THE BLOCK IS READ IN.

WBLOCK	1/1
	RETURNS THE ADDRESS OF A BUFFER CONTAINING THE BLOCK
	WHOSE NUMBER IS AT TOP.  THE BUFFER IS FLAGGED AS
	MODIFIED.  IF THE BLOCK IS NOT ALREADY IN MEMORY, IT
	IS NOT READ IN.

FLUSH	0/0
	WRITES OUT ALL MODIFIED BUFFERS.  THIS WORD MUST BE
	EXECUTED BEFORE SHUTTING DOWN THE SYSTEM OR CHANGING
	MEDIA TO ENSURE THAT THE INFORMATION ON THE STORAGE
	MEDIUM IS CURRENT.

EBUF	0/0
	FLAGS ALL BUFFERS AS EMPTY.  THIS WORD MUST BE USED
	WHEN CHANGING MEDIA.

UPDATE	0/0
	FLAGS THE MOST RECENTLY ACCESSED BUFFER AS MODIFIED.
	WHENEVER THE VALUE OF ANY WORD WITHIN AN I/O BUFFER
	IS MODIFIED, THIS WORD MUST BE CALLED, OTHERWISE THE
	MODIFIED VERSION WILL NOT BE WRITTEN BACK ON THE
	STORAGE MEDIUM.

LOAD AND ;F

N LOAD	EXECUTES OFF THE DISK STARTING AT BLOCK N.
	INBLK AND INBYTE ARE PUSHED ON THE LOOP STACK
	INBLK IS SET TO N; INBYTE IS SET TO 0.

;F	REVERTS TO EXECUTION FROM CALLING PROGRAM.
	INBYTE AND INBLK ARE POPPED FROM THE LOOP STACK.


STRING HANDLING WORDS
NAME	ARGS	DESCRIPTION

WORD	0/1	GET NEXT STRING FROM THE INPUT STREAM
		DELIMITED BY SPACE OR TAB.  LEADING DELIMITERS
		ARE IGNORED.  DELIMITER SEARCH IS TERMINATED
		BY NULL.  THE STRING IS	STORED ON THE END OF
		THE DICTIONARY.  THE FIRST BYTE OF THE STRING
		IS A CHARACTER COUNT. A NULL IS STORED AT THE
		END OF THE STRING BUT IS NOT INCLUDED IN THE
		CHARACTER COUNT.  END-OF-LINE FLAG IS SET TO -1
		IF END OF LINE IS ENCOUNTERED.  THE VALUE OF
		THE END-OF-LINE FLAG IS RETURNED ON THE STACK.
		IF A " OR \ IS THE FIRST CHARACTER OF A WORD,
		THE DELIMITER IS CHANGED TO " OR \.

S,	1/0	STORE STRING POINTED TO BY TOP OF STACK AT
		THE END OF THE DICTIONARY, ".D" IS UPDATED.

%	0/0*	SET THE END-OF-LINE FLAG TO -1.


DICTIONARY SEARCH WORDS
NAME	ARGS	DESCRIPTION

LOOKUP	1/(1,2)	TOP OF STACK IS POINTER TO STRING TO BE
		LOOKED UP IN THE DICTIONARY.  A DICTIONARY
		SEARCH IS PERFORMED FOR THE BRANCH OF THE
		DICTIONARY WHOSE ADDRESS IS AT THE TOP OF
		THE VOCABULARY STACK, AND IF MISSING, THE
		BRANCH WHOSE ADDRESS IS AT TOP - 1 IS SEARCHED
		ETC., UNTIL THE BOTTOM OF THE VOCABULARY
		STACK IS REACHED.  AT THIS POINT THE SEARCH
		FAILS.  IF SUCCESSFUL, A -1 IS STORED AT TOP
		AND A POINTER TO THE PARAMETER FIELD OF THE
		MATCHING DICTIONARY ENTRY AT TOP - 1.  OTHERWISE
		A 0 IS LEFT AT TOP.

ADDRESS	1/1	EXECUTE "LOOKUP".  TEST THE TOP OF THE
		STACK.  IF ZERO, EXECUTE "ERR" WITH THE
		MESSAGE "UNDEFINED".  OTHERWISE RETURN.


LITERAL HANDLING WORDS
NAME	ARGS	DESCRIPTION

LITERAL	1/0	PROCESS THE LITERAL STRING WHOSE ADDRESS IS AT TOP

ILITERAL
	1/(1,2)	A POINTER TO A STRING IS AT TOP.  IF THE STRING
		REPRESENTS A LEGAL INTEGER LITERAL, A -1 IS LEFT AT
		TOP, AND THE LITERAL VALUE IS LEFT AT TOP - 1.
		OTHERWISE, A 0 IS LEFT AT TOP.

SLITERAL
	1/1	A POINTER TO A STRING IS AT TOP.  IF THE STRING
		REPRESENTS A LEGAL STRING LITERAL, THE LITERAL
		IS OUTPUT TO THE COMPILE BUFFER PRECEDED BY THE
		ADDRESS OF "S()" AND A -1 IS LEFT ON THE STACK.
		OTHERWISE A 0 IS LEFT AT TOP.


COMPILER WORDS
NAME	ARGS	DESCRIPTION

^	0/0*	ZEROS THE END-OF-COMMAND FLAG, FORCING COMPILATION
		TO CONTINUE ON TO THE NEXT LINE.

PROMPT0	0/0	TYPES THE INITIAL PROMPT MESSAGE, I.E. A CARRIAGE
		RETURN, THE CURRENT VALUE OF "CHECK", AND
		A ">".

ERRMSG0	1/0	THE DEFAULT ERROR MESSAGE PRINTER; PRINTS THE ERROR
		MESSAGE AT TOP, THE CURRENT CONTENTS OF THE
		TOKEN BUFFER, AND EXITS VIA "ABORT".

UNDEFINED0 0/0	THE DEFAULT UNDEFINED SYMBOL HANDLER; TYPES THE
		MESSAGE "UNDEFINED" AND ABORTS.



***EOF***

